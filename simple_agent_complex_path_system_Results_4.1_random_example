breed [builds build]
breed [people person]
undirected-link-breed [linkbuilds linkbuild]

breed [patchpages patchpage]
directed-link-breed [linkpatchpages linkpatchpage]

patches-own [route is-building? my-xorigin my-yorigin pageID ]
people-own [destx desty buildwho almost-there? travel-length angle-change prior-angle xcor-backStep ycor-backStep SD-distance original-angle-between-dest memory-last-patch-x memory-last-patch-y find-a-max-patch a-max-patch-x a-max-patch-y]
builds-own [build-degree frq-visited]

patchpages-own [  rank new-rank ; for the diffusion approach
  visits ; for the random-surfer approach

]

breed [ city-labels city-label ]
breed [ country-labels country-label ]
breed [ country-vertices country-vertex ]
breed [ river-labels river-label ]

globals [

  nest
  food
  building-set
  building-hit-pro ; the probability of an agent's hitting a building
  rv
  patch-value-mean
  ht-index



  travel-length-difference-list

  saved-building-from-file
  num-building-fromfile
  num-portal-fromfile

  total-rank max-rank
  patch-page-rank-list
  who-patch-page-rank-list

  people-hit-times
  people-miss-times
  hit-ratio

  route-ratio-list

  indicator-frq-degree

  data-envilope
  hotspots-data
  building-data
  street-data
  portal-data

  feature-building-data
  patch_num
]

extensions [
  gis
  py
  nw
  matrix
  csv
  stats] ;; The network extension is used in this model.

to-report travel-diff
  if length travel-length-difference-list > 0[
    report (sum travel-length-difference-list / length travel-length-difference-list)]
end
to-report travel-diff2
  report 1
end
to my-test
  let my1 [1 2 3]
  let my2 [2 3 4]

  show abs my1 - my2
end
to python-test
  py:setup py:python
  (py:run
    "import math"
    "mydata=[1,2,3]")

  ;; Transfer data to Netlogo environment:
  let m py:runresult "[math.factorial(i) for i in range(10)]"
  let n py:runresult "mydata" ;Not working
  show n

  ;; Transfer data to Python environment:
  py:set "xx" [1 2 3]
  (py:run
    "x=[_+1 for _ in xx]"
   )
  show py:runresult "x"
end

to-report report_num_paths
  let rv_h []

  ask patches with [route > 0] [set rv_h insert-item 0 rv_h route ]
  ifelse length rv_h > 0 [
  let avg_rvh mean rv_h
  let rv_h_greaterMean []

    foreach rv_h [x -> if x > avg_rvh [set rv_h_greaterMean insert-item 0 rv_h_greaterMean x] ]
    report length rv_h_greaterMean]
  [report 0]

end


to-report report-ht-index
  set rv []
  ;ask patches with [is-building? != true and route != 0] [set rv insert-item 0 rv route ]
  ask patches with [route != 0] [set rv insert-item 0 rv route ]
;  set rv sort-by > rv
  ifelse length rv > 0 [
  py:setup py:python
  py:set "pixels" rv
  (py:run
    "def htb(data):"
    "    outp = []  # array of break points"
    "    def htb_inner(data):"
    "        data_length = float(len(data))"
    "        data_mean = sum(data) / data_length"
    "        head = [_ for _ in data if _ > data_mean]"
    "        while len(head) > 1 and len(head)/data_length <= 0.40:"
    "            outp.append(data_mean)"
    "            return htb_inner(head)"
    "    htb_inner(data)"
    "    outp.sort(reverse=True)"
    "    return len(outp)+1,outp"
    "ht_index,outp=htb(pixels)"
  )

  let here-ht-index py:runresult "ht_index"
  let here-patch-value-mean py:runresult "outp"
  set patch-value-mean here-patch-value-mean
  report here-ht-index
  ][report 0]
end


to create-cut-buildings
  if feature-building-data != 0 [
    let count-h 0
;    ask builds [ foreach feature-building-data [fbd -> if (gis:contains? fbd self) = false [set count-h count-h + 1 die] ] ]
    ask builds [ if (gis:contains? feature-building-data self) = false [set count-h count-h + 1 die] ]
    set building-hit-pro []
    ask builds [set build-degree count builds set building-hit-pro insert-item 0 building-hit-pro who]
    show length building-hit-pro
    ask people [;; set the destx and desty from breed builds
      if length building-hit-pro != 0 [

        let this-index random length building-hit-pro

        let this-dest turtle (item this-index building-hit-pro)

        set buildwho [who] of this-dest

        set destx [xcor] of this-dest
        set desty [ycor] of this-dest
        set original-angle-between-dest towards patch destx desty
        facexy destx desty
        set prior-angle heading
        ;    show (list destx desty)

      ]
    ]

  ]
end

to setup
  ifelse num-building-fromfile != 0 [
    clear-all

      show "# of builds:"
  show count builds
  ][
  clear-all
  ]
  set patch-page-rank-list []
  set who-patch-page-rank-list []
  set people-hit-times 0
  set people-miss-times 0
  set hit-ratio 0.0


  set travel-length-difference-list []




  ifelse building-network? = TRUE [

      create-network ] ;; Creates a social network if networks is true. Otherwise just creates a set of unconnected turtles.
  [randomBuilding ]

  if saved-building-from-file != 0 [show "Run" reset-building-from-file]

  ;  set food (list foodxy1 foodxy2 foodxy3 foodxy4)
  ask patches [
    set pcolor bg-color
    set route 0
    set my-xorigin -1
    set my-yorigin -1
  ]


    let nesttemp [ (list xcor ycor) ] of builds
    show "nesttemp:"
    show nesttemp
    show length nesttemp

    set nest nesttemp


  create-agents nest

  reset-ticks
end

to randomBuilding
  set building-set []
  let num-b-temp num-building - 1
  let dj true
  while [dj]
    [
      if num-b-temp = 0 [set dj false]
      ;      show dj

      let ran-pxcor random max-pxcor
      let ran-pycor random max-pycor

      if saved-building-from-file != 0 [
        let p-f item num-b-temp saved-building-from-file
        set ran-pxcor item 0 p-f
        set ran-pycor item 1 p-f
      ]
      set building-set insert-item 0 building-set list ran-pxcor ran-pycor
      ;      ifelse empty? building-set [set building-set insert-item 0 building-set list ran-pxcor ran-pycor]
      ;      []
      ;      show building-set
      ask patch ran-pxcor ran-pycor [
        sprout 1 [
          set color white
          set shape "house"
          let this-size random 5
;          set size this-size * 2
          set size 2

          ask patch-here
          [
            ;            show pxcor
            ;            show pycor
            set is-building? true
            ;        set pcolor yellow
            ;            ask neighbors [set is-building? true]
            set my-xorigin ran-pxcor
            set my-yorigin ran-pycor
          ]
          ask patches in-radius this-size [
            set is-building? true
            set my-xorigin ran-pxcor
            set my-yorigin ran-pycor
          ]
;          stamp
;          die
        ]
      ]
      set num-b-temp num-b-temp - 1
      ;      show num-b-temp
  ]
end

to go
  ;  if all? turtles [abs(xcor - destx)<= 2  and abs(ycor - desty)<= 2]
  ;  if all? turtles [
  ;    [my-xorigin] of patch-ahead 1 = destx and [my-yorigin] of patch-ahead 1 = desty or abs(xcor - destx)<= 2  and abs(ycor - desty)<= 2]
  ;;    abs(xcor - destx)<= 2  and abs(ycor - desty)<= 2]
  ;  [stop]

  if ticks >= num-ticks [stop]
  if ticks mod 100 = 0 [
    set ht-index report-ht-index

    render-patch
    set patch_num report_num_paths
;    set people-hit-times 0
;    set  people-miss-times 0
  ]

  if people-hit-times != 0[
    set hit-ratio people-hit-times / (people-hit-times + people-miss-times )]
;  plot-routes
;  plot-build-visits

  ask people [
    if who >= ticks [ stop ] ;; delay initial departure

    let this-buildwho buildwho
    if memory-last-patch-x = 0 and memory-last-patch-y = 0 [set memory-last-patch-x -1 set memory-last-patch-y -1]

    let d-x [xcor] of turtle this-buildwho
    let d-y [ycor] of turtle this-buildwho

    let distance-here (d-x - xcor) * (d-x - xcor) + (d-y - ycor) * (d-y - ycor)
    let distance-here-dest sqrt distance-here

    ifelse distance-here-dest <= speed * 1.5
    [

      if length building-hit-pro != 0 [
;        show "AHA-1"
        let this-index random length building-hit-pro

        let this-dest-who item this-index building-hit-pro


        let this-dest-who-destx [xcor] of turtle this-dest-who
        let this-dest-who-desty [ycor] of turtle this-dest-who
        ifelse this-dest-who = this-buildwho [ ; 两次获得的目的地ID相同或距离太近

          set this-index int this-index + 0.5 * length building-hit-pro
          if this-index >= length building-hit-pro [set this-index this-index - length building-hit-pro]
          set this-dest-who item this-index building-hit-pro
          set buildwho this-dest-who
          let this-destx  [xcor] of  turtle this-dest-who
          let this-desty  [ycor] of  turtle this-dest-who
          set travel-length-difference-list insert-item 0 travel-length-difference-list (abs (travel-length - SD-distance))
          set destx this-destx
          set desty this-desty
          set SD-distance distancexy destx desty
          set original-angle-between-dest towards patch destx desty
;
          if travel-length > 0[

          ]

          set travel-length 0.0
          set angle-change 0.0
;          set almost-there? false
;          show "AHA-2"
          ;          show "gl 1"
        ][
          set buildwho this-dest-who
          let this-destx  [xcor] of  turtle this-dest-who
          let this-desty  [ycor] of  turtle this-dest-who
          set travel-length-difference-list insert-item 0 travel-length-difference-list ((abs travel-length - SD-distance))
          set destx this-destx
          set desty this-desty
          set SD-distance distancexy destx desty
          set original-angle-between-dest towards patch destx desty

          set travel-length 0.0
          set angle-change 0.0
;          set almost-there? false
          ;        show "gl 2"
;          show "AHA-3"
        ]
        ;        show [who] of this-dest

    ]
      ; the frq-visited of destination build + 1
      ask turtle this-buildwho [set frq-visited frq-visited + 1
;        show frq-visited
      ]

    ]
    [

      let got-route? find-route distance-here-dest ; find a route around firstly

;      ifelse speed-here = speed [ show "move >1 steps"
      set find-a-max-patch got-route?
      ifelse got-route?  [set people-hit-times people-hit-times + 1] [set people-miss-times people-miss-times + 1]


      repeat speed [
        let from-page pageID
;        set prior-angle heading
        set xcor-backStep xcor
        set ycor-backStep ycor

        set memory-last-patch-x pxcor
        set memory-last-patch-y pycor

        fd 1
        set route route + 1
;        set travel-length travel-length + 1
        set travel-length travel-length + (distancexy xcor-backStep ycor-backStep)
        set angle-change angle-change + abs (heading - prior-angle)
        set prior-angle heading
;        set pcolor gray - route * 1.3



        let to-page pageID
        if from-page != to-page [


        ]

      ]


      facexy destx desty
  ]]
  tick

end
to-report find-route [distance-local]
  ;  let next-jump-to
  let pt patch-here
  let got-route-h? false

  let memory-last-patch-x-here memory-last-patch-x
  let memory-last-patch-y-here memory-last-patch-y



  let head-range min list distance-local head-distance

  if any? patches with [route != 0 and pxcor != [pxcor] of pt and pycor != [pycor] of pt and pxcor != memory-last-patch-x-here and pycor != memory-last-patch-y-here] in-cone head-range head-angle-max [
    set got-route-h? true

    let patch-this-n patches with [route != 0 and pxcor != [pxcor] of pt and pycor != [pycor] of pt and pxcor != memory-last-patch-x-here and pycor != memory-last-patch-y-here] in-cone head-range head-angle-max with-max [route]
    let patch-this min-one-of patch-this-n [distance myself]

    ;    show [route] of patch-this
    let pxc-pthis [pxcor] of patch-this
    let pyc-pthis [pycor] of patch-this
    ;    show pxc-pthis
    ;    show pyc-pthis
;    set prior-angle heading
    set heading towards patch pxc-pthis pyc-pthis

    set a-max-patch-x pxc-pthis
    set a-max-patch-y pyc-pthis

  ]


report got-route-h?
end


to correct-path

  let dj true
  let counting 0
  while [dj]
  [
    if counting > 10 [stop]
    set counting counting + 1
    ;    show counting
    ifelse patch-ahead 1 != nobody [

      ifelse [is-building?] of patch-ahead 1 = true [
        ;        let xhere patch-ahead 1
        ifelse ([pxcor] of patch-ahead 1 - destx)*([pxcor] of patch-ahead 1 - destx) +  ([pycor] of patch-ahead 1 - desty)* ([pycor] of patch-ahead 1 - desty)<= 4

        ;        ifelse ([my-xorigin] of patch-ahead 1 - destx)*([my-xorigin] of patch-ahead 1 - destx) +  ([my-yorigin] of patch-ahead 1 - desty)* ([my-yorigin] of patch-ahead 1 - desty)<= 2
        [stop]
        [let this-random random 100
          if this-random >= 50 [rt 50]
          if this-random < 50  [lt 50]]
      ][stop]
    ][let this-random random 100
      if this-random >= 50 [rt 50]
      if this-random < 50  [lt 50]
      ;      show 2
    ]
  ]
;  let d-x item 0 [xcor] of builds with [who = buildwho]
;  let d-y item 0 [ycor] of builds with [who = buildwho]

  let d-x  [xcor] of turtle buildwho
  let d-y  [ycor] of turtle buildwho

  show (d-x - xcor)*(d-x - xcor) + (d-y - ycor)*(d-y - ycor)

end
;to correct-path
;    if patch-at 0 -1 = nobody
;        [ rt 100 ]
;     if patch-at 0 1 = nobody
;        [ lt 100 ]
;end
;; turtle procedure; wiggle a random amount, averaging zero turn
to wiggle [angle]
  rt random-float angle
  lt random-float angle
end

to create-agents-old [here-nest]
  let temp 0
  create-people number-of-agents [
    set color red
    set size 2
    set almost-there? false
;    let this-nest item (temp mod 4) here-nest
    let this-nest one-of here-nest
    setxy item 0 this-nest item 1 this-nest
    set temp temp + 1
    set travel-length 0.0
    set angle-change 0.0


    ;    let this-dest item (temp mod 4) food
    ;    set destx item 0 this-dest
    ;    set desty item 1 this-dest
    ifelse building-network? = false [
      let this-dest one-of building-set
      set destx item 0 this-dest
      set desty item 1 this-dest
      facexy destx desty
      set prior-angle heading
      ;    show (list destx desty)

    ]
    [;; set the destx and desty from breed builds
      if length building-hit-pro != 0 [
        let this-index random length building-hit-pro

        let this-dest turtle item this-index building-hit-pro

        set buildwho [who] of this-dest

        set destx [xcor] of this-dest
        set desty [ycor] of this-dest
        set original-angle-between-dest towards patch destx desty
        facexy destx desty
        set prior-angle heading

      ]
    ]
  ]

end

to create-agents [here-nest]
  let temp 0
  create-people number-of-agents [
    set color red
    set size 2
    set almost-there? false


    let this-nest one-of here-nest
;    let this-nest item (temp mod 4) here-nest

    setxy item 0 this-nest item 1 this-nest
    set temp temp + 1
    set travel-length 0.0
    set angle-change 0.0


    ;    let this-dest item (temp mod 4) food
;    set destx item 0 this-dest
;    set desty item 1 this-dest
          let this-index1 random length building-hit-pro
;     let this-dest builds with [who = item this-index building-hit-pro]
      let this-dest1 turtle item this-index1 building-hit-pro
      set destx [xcor] of this-dest1
      set desty [ycor] of this-dest1
    set buildwho [who] of this-dest1

    ifelse num-building-fromfile != 0 [
      ;; set the destx and desty from breed builds


        set building-hit-pro []
        ask builds [
        repeat build-degree [set building-hit-pro insert-item 0 building-hit-pro who]

      ]
;    ]

      let this-index random length building-hit-pro
;     let this-dest builds with [who = item this-index building-hit-pro]
      let this-dest turtle item this-index building-hit-pro
      set destx [xcor] of this-dest
      set desty [ycor] of this-dest

      while [ (destx = pxcor) and (desty = pycor) ]
      [
        set this-index random length building-hit-pro
        ;     let this-dest builds with [who = item this-index building-hit-pro]
        set this-dest turtle item this-index building-hit-pro
        set destx [xcor] of this-dest
        set desty [ycor] of this-dest
      ]

        set buildwho [who] of this-dest

        set original-angle-between-dest towards patch destx desty
        facexy destx desty
        set prior-angle heading
        ;    show (list destx desty)

    ]
    [
      ifelse building-network? = false [
      let this-dest one-of building-set
      set destx item 0 this-dest
      set desty item 1 this-dest
      facexy destx desty
      set prior-angle heading
      ;    show (list destx desty)

      ][]
   ]
  ]

end


to reset-building-from-file
  let num-b-temp 0

  foreach saved-building-from-file [x -> ask build num-b-temp [ set xcor item 0 x set ycor item 1 x
    set build-degree item 2 x] set num-b-temp num-b-temp + 1 ]

  mark-builds-on-patches "n"
  display
end

to create-network ;; Includes procedures for four kinds of networks.

  if network-type = "random" [ ;; Creates one random network (Erdös-Renyi random network).
    create-builds num-building ;; Create number-of-building turtles.
    repeat (network-param * count builds) / 2 [ ;; Divide by two (because a link connects two turtles).
      ask one-of builds [

        let here-link one-of other builds with [ not linkbuild-neighbor? myself ]
        if here-link != nobody [
          create-linkbuild-with one-of other builds with [ not linkbuild-neighbor? myself ] ];; Ask a random turtle to create link with another random turtle.
      ]

    ]
  ]

  if network-type = "small-world" [ ;; Creates a Watts-Strogatz small-world network (high clustering coefficient). Uses the algorithm from NetLogo network extension (https://ccl.northwestern.edu/netlogo/docs/nw.html).
                                    ;    nw:generate-watts-strogatz turtles links num-building network-param 0.1 [ fd 10 ] ;; Structure: turtle-breed link-breed num-nodes neighborhood-size rewire-probability optional-command-block
    nw:generate-watts-strogatz builds linkbuilds num-building network-param 0.1 [ fd 10 ] ;; Structure: turtle-breed link-breed num-nodes neighborhood-size rewire-probability optional-command-block

  ]

  if network-type = "preferential" [ ;; Creates a scale-free network with hubs (preferential attachment). This is the Barabási–Albert network model. Uses the algorithm from NetLogo network extension (https://ccl.northwestern.edu/netlogo/docs/nw.html).
    nw:generate-preferential-attachment builds linkbuilds num-building network-param [ fd 10 ;; Structure: turtle-breed link-breed num-nodes min-degree optional-command-block
                                                                                             ;      repeat 3 [
                                                                                             ;        ;   layout-spring turtles links 0.2 4.0 500 ;; Layout procedure (mainly cosmetic).
                                                                                             ;        display  ;; For smooth animation.
                                                                                             ;      ]
    ]
  ]


  if network-type = "KE" [ ;; Creates a scale-free network with high clustering, the Klemm-Eguíluz model.
                           ;; The following algorithm is adapted with permission from Fernando Sancho Caparrini's "Complex Networks Toolbox", see http://www.cs.us.es/~fsancho/?e=162#KE for details and a conceptual model.
                           ;    clear-all
    create-builds network-param [ ;; The algorithm begins with an initial set of turtles. The number of initial turtles is defined by network-param. (This is m0 in the original KE algorithm.)
                                  ;      set color red
    ]
    ask builds [
      create-linkbuilds-with other builds
    ]
    let active builds with [self = self]
    let no-active no-turtles
    repeat (num-building - network-param) [
      create-builds 1 [
        set color white
        foreach shuffle (sort active) [ [ac] ->
          ifelse (random-float 1 < mu or count no-active = 0)
          [
            create-linkbuild-with ac
          ]
          [
            let cut? false
            while [not cut?] [
              let nodej one-of no-active
              let kj [count my-linkbuilds] of nodej
              let S sum [count my-linkbuilds] of no-active
              if (kj / S) > random-float 1 [
                create-linkbuild-with nodej
                set cut? true
              ]
            ]
          ]
        ]
        set active (turtle-set active self)
        let cut? false
        while [not cut?] [
          let nodej one-of active
          let kj [count my-linkbuilds] of nodej
          let S sum [1 / (count my-linkbuilds)] of active
          let P (1 / (kj * S))
          if P > random-float 1 [
            set no-active (turtle-set no-active nodej)
            set active active with [self != nodej]
            set cut? true
          ]
        ]
      ]
  ]]

  if network-type = "evenly-random"[
    create-builds num-building
  ]



  mark-builds-on-patches "r"
end

to mark-builds-on-patches [is-randomxy]

  set building-hit-pro []

  ask builds [
    if is-randomxy = "r" [
          setxy random-xcor random-ycor]
    set color white
    set shape "house"
;    set frq-visited 0
    ; calculate degree of this building
    ;    show my-linkbuilds
    let this-size count my-linkbuilds
    repeat this-size [
      set building-hit-pro insert-item 0 building-hit-pro who
    ]
    if num-building-fromfile = 0 [
      if this-size = 0 [set this-size count builds set building-hit-pro insert-item 0 building-hit-pro who] ; if evenly-random is selected
      set build-degree this-size]
    set label build-degree
    set label-color red

    ;    show building-hit-pro
    ;    let this-size 5
    ;    show count my-trajs
;    set size this-size
    set size 3
    ;    set size this-size * 2
    let ran-pxcor 0
    let ran-pycor 0
    ask patch-here
          [
            set is-building? true
            set my-xorigin pxcor
            set my-yorigin pycor
            set ran-pxcor pxcor
            set ran-pycor pycor
    ]

    ask patches in-radius (this-size / 2) [
      set is-building? true
      set my-xorigin ran-pxcor
      set my-yorigin ran-pycor
    ]

  ]
  ask linkbuilds [hide-link]
end

to hide-buildings
  ask builds [hide-turtle]
end
to show-buildings
  ask builds [show-turtle]
end
to hide-agents
  ask people [hide-turtle]
end
to show-agents
  ask people [show-turtle]
end


to render-patch
  let render-color [ 15 15 45 45 65 65 95 95 102 102 ]
  if ht-index >= 2 [
    let is-first? true
    let color-index 0
    foreach patch-value-mean [this-mean ->
      if is-first? = true [
        set is-first?  false
        ask patches with [route >= this-mean ] [set pcolor item color-index render-color]
      set color-index color-index + int 10 / ht-index]

      ask patches with [route < this-mean and route > 0] [set pcolor item color-index render-color]
      set color-index color-index + int 10 / ht-index

    ]

  ]

end


  ;;;;;;;;;;;;;Plot Part:;;;;;;;;;;;;;;;;;;;;;;;;;
to plot-build-visits
;  if ticks mod 50 = 0 [
  clear-all-plots

  let fv []
  ask builds [set fv insert-item 0 fv frq-visited]
  set fv sort-by > fv
;  set-histogram-num-bars length bd
;  show "Building degree"
;  show bd
  let index-h 0
  foreach fv [
;    show index-h
;    show item index-h bd
    set-current-plot "#Visits of buildings"
;    clear-plot
    plotxy index-h item index-h fv
    set-current-plot "Log #visits of buildings"
;    clear-plot
    let new-i index-h + 1
    let log-y item index-h fv
    if log-y != 0 [
      plotxy log new-i 10 log log-y 10
    ]
    set index-h index-h + 1

  ]
end

to plot-routes
  clear-plot
  if ticks mod 50 = 0 [
;  clear-all-plots
;  set-current-plot "Routes value"

  set rv []
  ask patches with [is-building? != true] [set rv insert-item 0 rv route ]
  set rv sort-by > rv
;  show rv

  let index-h 0
  foreach rv [
      set-current-plot "Routes value"
;clear-plot
;      set-current-plot-pen "rv-pen"
      plotxy index-h item index-h rv
;      set-current-plot-pen "rv-log-pen"

      set-current-plot "Routes Value Log"
;clear-plot
      let new-i index-h + 1
      let log-y item index-h rv
      if log-y != 0 [
        plotxy log new-i 10 log log-y 10]
  set index-h index-h + 1]
  ]

end
